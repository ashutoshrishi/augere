/* Stage.js defines the staging area which is used in the editor to load plugins
 * and display their data when activated
 */

var fs = require('fs');

function Stage() {
    /* initArea: initialize the div which will be used as the stage */
    function initArea(stageDiv) {
        // stageDiv.innerHTML = "Testing, staging area activated";
        this.stageDiv = $("#stage");

        /* Need a register to keep the active boxes references and expire
         * them when an when needed */
        this.boxRegister  = [];

        /* Plugin registry keeps a reference of all the module files in the
         * plugins/ directory. */
        this.pluginRegistry = {};

        var plugin_list = fs.readdirSync("node_modules/plugins/");
        for (var i = 0; i < plugin_list.length; i++) {
            var temp = require('plugins/' + plugin_list[i]);
            this.pluginRegistry[temp.invokeID] = temp;
        }

        /* A function needs to keep the check on the timouts of the boxes,
         * Expiry timeouts are run in per second basis.
         * TODO: move the register check function to a
         * global background process
        */
        var timerID = setInterval(function(register) {
            return function() {
                stageUpdate(register);
                registerCleanup(register);
            };
        }(this.boxRegister), 1000);


        /* boxid to identify boxes */
        global.boxid = 0;
    }

    function stageUpdate(register) {
        if (typeof register !== 'undefined' && register.length > 0) {
            $.each(register, function(i, val) {
                if (typeof val.div === 'undefined') {
                    var boxdiv = generateBoxDiv(val.borderColor);
                    appendBox(boxdiv, val);
                    val.div = boxdiv;
                } else if (val.htmlStateChange) {
                    val.div.find("#body").html(val.html);
                    val.htmlStateChange = false;
                }
            });
        }
    }

    function invokeBox(boxkey, query) {
        if (this.pluginRegistry[boxkey]) {
            var mod = this.pluginRegistry[boxkey],
                modbox = mod.build(query);
            this.boxRegister.push(modbox);
        }
    }
    /* generateBoxDiv: generate a div DOM element to append in the
     * staging area based on certain parameters. */
    function generateBoxDiv(color) {
        var boxDiv = $("<div><h2 id=\'title\'></h2><span id=\'body\'></span></div>");
        boxDiv.addClass("box-simple");

        if (color) { boxDiv.css("border-top", "3px solid " + color); }
        return boxDiv;
    }

    /* appendBox: append a information box as a css div at the end of
     * the stage */
    function appendBox($boxDiv, box) {
        $boxDiv.find("#title").text(box.title);
        $boxDiv.find("#body").html(box.html);
        $boxDiv.appendTo($("#stage"));
    }

    /* Function to cleanup the boxRegister and expire the boxes which
     * have crossed their timeouts.
    */
    function registerCleanup(register) {
        if (typeof register != 'undefined' && register.length > 0) {
        /* Now remove the divs with 0 timeout */
            $.each(register, function(i, val) {
                if (typeof val.timeout != 'undefined' &&
                    val.timeout != -1) {

                    val.timeout -= 1;
                    if (val.div && val.timeout == 0) {
                        val.div.slideUp("slow", function () {
                            val.div.remove();
                        });
                    }
                }
                // if (typeof val.box != 'undefined' && val.box.timeout != 0) {
                //     console.log(val.box.html);
                //     if (val.box.htmlStateChange == true) {
                //         val.div.find("#body").html(val.box.html);
                //         val.box.htmlStateChange = false;
                //     }
                // }
            });

            // remove the useless boxes
            for (var i = 0; i < register.length; i++) {
                if (register[i].timeout == 0) {
                    register.splice(i, 1);
                }
            }
        }
    }


    this.initArea = initArea;
    this.appendBox = appendBox;
    this.invokeBox = invokeBox;
}

module.exports = new Stage;
